Algorithm:
https://leetcode-cn.com/problems/roman-to-integer/
思路 ：
本题有以下四种情形：
以I和V开头为个位、以X和L开头为十位、以C和D开头为百位、以M开头为千位
将所有数字存入map中，对字符串进行匹配然后进行组合计算得出结果
class Solution {
public:
    int romanToInt(string s) {
        map<string,int> ism = {{"I",1},{"II",2},{"III",3},{"IV",4},{"V",5},
                               {"VI",6},{"VII",7},{"VIII",8},{"IX",9},
                               {"X",10},{"XX",20},{"XXX",30},{"XL",40},{"L",50},
                               {"LX",60},{"LXX",70},{"LXXX",80},{"XC",90},
                               {"C",100},{"CC",200},{"CCC",300},{"CD",400},{"D",500},
                               {"DC",600},{"DCC",700},{"DCCC",800},{"CM",900},
                               {"M",1000},{"MM",2000},{"MMM",3000}
                             };
        string thousandsPlace;
        string hundredsPlace;
        string tensPlace;
        string unitsPlace;
        if( s[0] == 'I' || s[0] == 'V'){
            int i = 0;
            while( i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }else if(s[0] == 'X' || s[0] == 'L'){
            int i = 0;
            while( (s[i] != 'I' || s[i] != 'V')&&i < s.size()){
                tensPlace.push_back(s[i]);
                i++;
            }
            while(i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }else if(s[0] == 'C' || s[0] == 'D'){
            int i = 0;
            while((s[i] != 'X' || s[i] != 'L')&&i < s.size()){
                hundredsPlace.push_back(s[i]);
                i++;
            }
            while((s[i] != 'I' || s[i] != 'V') && i < s.size()){
                 tensPlace.push_back(s[i]);
                 i++;
            }
            while( i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }else if(s[0] == 'M'){
            int i = 0;
            while((s[i] != 'C' || s[i] != 'D')&&i < s.size()){
                thousandsPlace.push_back(s[i]);
                i++;
            }
            while((s[i] != 'X' || s[i] != 'L') && i < s.size()){
                 hundredsPlace.push_back(s[i]);
                 i++;
            }
            while( (s[i] != 'I' || s[i] != 'V') && i < s.size()){
                tensPlace.push_back(s[i]);
                i++;
            }
            while(i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }
        int result = 0;
        if( !thousandsPlace.empty() && !hundredsPlace.empty() && !tensPlace.empty() && !unitsPlace.empty()){
              result += ism[thousandsPlace] + ism[hundredsPlace] + ism[tensPlace] + ism[unitsPlace];
        }else if(!thousandsPlace.empty() && !hundredsPlace.empty() && !tensPlace.empty()){
              result += ism[thousandsPlace] + ism[hundredsPlace] + ism[tensPlace];
        }else if(!thousandsPlace.empty() && !hundredsPlace.empty()){
              result += ism[thousandsPlace] + ism[hundredsPlace];
        }else if(!thousandsPlace.empty()){
              result += ism[thousandsPlace];
        }else if( !hundredsPlace.empty() && !tensPlace.empty() && !unitsPlace.empty()){
            result += ism[hundredsPlace] + ism[tensPlace] + ism[unitsPlace];
        }else if( !hundredsPlace.empty() && !tensPlace.empty()){
            result += ism[hundredsPlace] + ism[tensPlace];
        }else if( !hundredsPlace.empty()){
            result += ism[hundredsPlace];
        }else if( !tensPlace.empty() && !unitsPlace.empty()){
            result += ism[tensPlace] + ism[unitsPlace];
        }else if( !tensPlace.empty()){
            result += ism[tensPlace];
        }else if( !unitsPlace.empty()){
            result += ism[unitsPlace];
        }
        return result;
    }
};

Review:

Tip:

Share:
