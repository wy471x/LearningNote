Algorithm:
https://leetcode-cn.com/problems/roman-to-integer/
思路 ：
本题有以下四种情形：
以I和V开头为个位、以X和L开头为十位、以C和D开头为百位、以M开头为千位
将所有数字存入map中，对字符串进行匹配然后进行组合计算得出结果
class Solution {
public:
    int romanToInt(string s) {
        map<string,int> ism = {{"I",1},{"II",2},{"III",3},{"IV",4},{"V",5},
                               {"VI",6},{"VII",7},{"VIII",8},{"IX",9},
                               {"X",10},{"XX",20},{"XXX",30},{"XL",40},{"L",50},
                               {"LX",60},{"LXX",70},{"LXXX",80},{"XC",90},
                               {"C",100},{"CC",200},{"CCC",300},{"CD",400},{"D",500},
                               {"DC",600},{"DCC",700},{"DCCC",800},{"CM",900},
                               {"M",1000},{"MM",2000},{"MMM",3000}
                             };
        string thousandsPlace;
        string hundredsPlace;
        string tensPlace;
        string unitsPlace;
        if( s[0] == 'I' || s[0] == 'V'){
            int i = 0;
            while( i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }else if(s[0] == 'X' || s[0] == 'L'){
            int i = 0;
            while(s[i] != 'I' && s[i] != 'V' && i < s.size()){
                tensPlace.push_back(s[i]);
                i++;
            }
            while(i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }else if(s[0] == 'C' || s[0] == 'D'){
            int i = 0;
            while(s[i] != 'X' && s[i] != 'L' && s[i] != 'I' && s[i] != 'V' && i < s.size()){
                hundredsPlace.push_back(s[i]);
                i++;
            }
            while(s[i] != 'I' && s[i] != 'V' && i < s.size()){
                 tensPlace.push_back(s[i]);
                 i++;
            }
            while( i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }else if(s[0] == 'M'){
            int i = 0;
            while(s[i] != 'C' && s[i] != 'D' && s[i] != 'X' && s[i] != 'L' && s[i] != 'I' && s[i] != 'V' && i < s.size()){
                thousandsPlace.push_back(s[i]);
                i++;
            }
            while(s[i] != 'X' && s[i] != 'L' && s[i] != 'I' && s[i] != 'V' && i < s.size()){
                 hundredsPlace.push_back(s[i]);
                 i++;
            }
            while(s[i] != 'I' && s[i] != 'V' && i < s.size()){
                tensPlace.push_back(s[i]);
                i++;
            }
            while(i < s.size()){
                unitsPlace.push_back(s[i]);
                i++;
            }
        }
        int result = 0;
       
        if( !thousandsPlace.empty() && !hundredsPlace.empty() && !tensPlace.empty() && !unitsPlace.empty()){
              result += ism[thousandsPlace] + ism[hundredsPlace] + ism[tensPlace] + ism[unitsPlace];
        }else if(!thousandsPlace.empty() && !hundredsPlace.empty() && !tensPlace.empty()){
              result += ism[thousandsPlace] + ism[hundredsPlace] + ism[tensPlace];
        }else if(!thousandsPlace.empty() && !hundredsPlace.empty() && !unitsPlace.empty()){
        	  result += ism[thousandsPlace] + ism[hundredsPlace] + ism[unitsPlace];
        	  cout<<result<<endl;
        }else if(!thousandsPlace.empty() && !tensPlace.empty() && !unitsPlace.empty()){
			  result += ism[thousandsPlace] + ism[tensPlace] + ism[unitsPlace];
        }else if(!thousandsPlace.empty() && !hundredsPlace.empty()){
              result += ism[thousandsPlace] + ism[hundredsPlace];
              cout<<result<<endl;
		}else if( !thousandsPlace.empty() && !tensPlace.empty()){
			  result += ism[thousandsPlace] + ism[tensPlace];
		}else if( !thousandsPlace.empty() && !unitsPlace.empty()){
			  result += ism[thousandsPlace] + ism[unitsPlace];
		}
		else if(!thousandsPlace.empty()){
              result += ism[thousandsPlace];
        }
		else if( !hundredsPlace.empty() && !tensPlace.empty() && !unitsPlace.empty()){
            result += ism[hundredsPlace] + ism[tensPlace] + ism[unitsPlace];
        }else if( !hundredsPlace.empty() && !tensPlace.empty()){
            result += ism[hundredsPlace] + ism[tensPlace];
        }else if(!hundredsPlace.empty() && !unitsPlace.empty()){
		    result += ism[hundredsPlace] + ism[unitsPlace];
		}
		else if( !hundredsPlace.empty()){
            result += ism[hundredsPlace];
        }
		else if( !tensPlace.empty() && !unitsPlace.empty()){
        	
            result += ism[tensPlace] + ism[unitsPlace];
        }else if( !tensPlace.empty()){
            result += ism[tensPlace];
        }
		else if( !unitsPlace.empty()){
            result += ism[unitsPlace];
        }
        return result;
    }
};

Review:
本周我阅读了来自medium上netflix关于不健康的JVM垃圾回收的应对方法，受益良多。
具体可见：https://medium.com/@NetflixTechBlog/introducing-jvmquake-ec944c60ba70
针对JVM应用像Cassandra和Elasticsearch，在某些情况下，例如死查询或是数据存储
的bug都将会造成内存耗尽，并且这样会触发垃圾回收的循环或甚至是耗尽JVM的内存耗尽
netflix团队已经喜欢使用JVMKILL去缓解这种情况，而jvmkill是一种跑在使用jvmti API
的jvm进程的代理。在JVM没有100%耗尽内存时，jvmkill无法注意到这个问题，但是我们
的客户端却可以快速的抓住这个问题，这个问题便是数据存储结点的生产效率已经显著下降了
4个数量级。
针对上述问题的解决方案是： identify and kill bad JVMs Proactively
所以后面就有了jvmquake实现来解决jvmkill无法处理的问题提出了类似于短板效应的debt 
counter算法去追踪不正常的JVM，并且同时设置门槛去判断JVM的健康程度。本文最后还同时
告诉我们要如何去处理现场的证据，通过这些数据来整段是属于哪种类型的问题，比如坏查询
、硬件、配置等。

Tip:
初涉java，本人发现java中的单元测试功能对于驱动式开发开发效率是极其重要。
测试框架将项目代码与测试代码进行了分离，针对测试即可观察到实际代码的错误
之处。
具体可见：https://www.liaoxuefeng.com/wiki/1252599548343744/1255945269146912

Share:
