Algorithm:
problem 1 :
https://leetcode-cn.com/problems/median-of-two-sorted-arrays/
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        double median;
        // nums1 is empty
        if(nums1.empty())
        {
            int len2 = nums2.size();
            if(nums2.size() % 2 == 0)
            {
                median = (double)(nums2[len2 / 2 - 1] + nums2[len2 / 2]) / 2;
            }
            else
            {
                median = nums2[len2 / 2];
            }
            return median;
        }
        //nums2 is empty
        else if(nums2.empty()){
            int len1 = nums1.size();
            if(nums1.size() % 2 == 0)
            {
                median =(double)(nums1[len1 / 2 - 1] + nums1[len1 / 2]) / 2;
            }
            else
            {
                median = nums1[len1 / 2];
            }
            return median;
        }
        median = mergeArray(nums1,nums2);
        return median;
    }
    //merge two array 
    double mergeArray(vector<int>& arr1,vector<int>& arr2)
    {
        double result;
        vector<int> mergeArray;
        vector<int>::iterator beg1 = arr1.begin(),end1 = arr1.end();
        vector<int>::iterator beg2 = arr2.begin(),end2 = arr2.end();
        while(beg1 != end1 && beg2 != end2)
        {
            if( *beg1 < *beg2)
            {
                mergeArray.push_back(*beg1);
                beg1++;
            }
            else
            {
                mergeArray.push_back(*beg2);
                beg2++;
            }
        }
        while(beg1 != end1)
        {
            mergeArray.push_back(*beg1);
            beg1++;
        }
        while(beg2 != end2)
        {
            mergeArray.push_back(*beg2);
            beg2++;
        }
        if(mergeArray.size() % 2 == 0)
        {
            result =(double) (mergeArray[mergeArray.size() / 2 - 1] + mergeArray[mergeArray.size() / 2]) / 2;
        }
        else
        {
            result = mergeArray[mergeArray.size() / 2];
        }
        return result;
    }
};
此题，运用合并算法，将两个有序数组进行合并形成一个有序数组，再进行查找
problem 2 :
https://leetcode-cn.com/problems/longest-palindromic-substring/
class Solution {
public:
    string longestPalindrome(string s) {
        string maxString;
        for(int i = 0; i < s.size(); ++i){
            for(int j = 0;j < s.size(); ++j){
                if(isPalindromicString(s.substr(i,j-i+1)) 
                   && s.substr(i,j-i+1).size() > maxString.size()){
                    maxString = s.substr(i,j-i+1);
                }
            }
        }
        return maxString;
    }
    bool isPalindromicString(string s){
        int len = s.size();
        int i = 0, j = len -1;
        if(len % 2 == 0){
            while(i < j){
                if(s[i] != s[j])
                {
                    break;
                }
                i++;
                j--;
            }
            if(i > j)
                return true;
            else
                return false;
        }
        else{
            while(i < j){
                if(s[i] != s[j]){
                    break;
                }
                i++;
                j--;
            }
            if(i == j)
                return  true;
            else
                return false;
        }
    }
};
此题运用暴力法，时间超时

Review:
本周我看到耗子叔推荐的那篇如何提高自己编程能力的文章感觉感悟挺深的。这篇文章从几个点分别阐述了作为程序员应该具有的素养，以及
平时如何去锻炼自己各方面的能力。在这里给出该文章的链接：
http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/

Tip:
logcat指令查看日志信息
logcat参数说明：
-c :清除缓冲区中的全部日志信息并退出
-s :设置过滤器
命令详情可见：
https://www.cnblogs.com/jianxu/p/5468839.html

Share:
由于自己刚刚进入职场，需要学习的地方还是很多。通过了耗子叔的专栏，我才真正的明白自己需要努力的方向在哪里。
以下是我个人体会而已。
                                个人体会
决定了坚持这条路，就不要轻言放弃，我知道自己也不是这样的性格。既然自己已经选择在
这条路上走下去，那么即便前面是荆棘重重，自己也要勇敢的往前冲。今天是一个特殊的日子
，非常感谢自己能够看到耗子叔的专栏，这个专栏于我的意义可能就是确定自己未来的方向
以及职业发展了。
