Algorithm
problem 1
https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/submissions/
volience solution : O(n)
class Solution {
public:
    int findMin(vector<int>& nums) {
        int min = nums[0];
        for(int i = 0; i < nums.size(); i++){
            if(min > nums[i])
                min = nums[i];
        }
        return min;
    }
};
binary solution : O(logn)
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size() == 1 || nums[0] < nums[nums.size() - 1])
            return nums[0];
        int low = 0, high = nums.size() - 1;
        while(low <= high){
            int mid = (low + high) / 2;
            if(nums[mid] > nums[mid + 1])
                return nums[mid + 1];
            if(nums[mid] < nums[mid - 1])
                return nums[mid];
            if(nums[mid] > nums[0])
                low = mid + 1;
            else
                high = mid - 1;
        }
        return -1;
    }
};
problem 2
https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/submissions/
Complexity Anlysis: Time O(n^2) Space O(1)
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
                    vector<int> result;
                    for(int i = 0; i < numbers.size(); i++){
                        for(int j = i + 1; j < numbers.size(); j++){
                            if(numbers[i] + numbers[j] == target){
                                result.push_back(i + 1);
                                result.push_back(j + 1);
                            }
                        }
                    }
                    return result;
    }
};
Complexity Anlysis : Time O(logn) Space O(1)
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
                int low = 0, high = numbers.size() - 1;
                while(low < high){
                    if(numbers[low] + numbers[high] > target)
                        high--;
                    else 
                        if(numbers[low] + numbers[high] < target)
                            low++;
                        else
                            return vector<int>({low + 1, high + 1});
                }

                return vector<int>({-1,-1});
    }
};
problem 3:
https://leetcode-cn.com/problems/remove-element/submissions/
Complexity Anlysis: Time O(n) , Space O(1) 
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
            for(auto it = nums.begin(); it != nums.end();){
                if(*it == val)
                    it = nums.erase(it);
                else
                    it++;
            }
            return nums.size();
    }
};

Review
https://netflixtechblog.com/engineering-a-studio-quality-experience-with-high-quality-audio-at-netflix-eaa0b6145f32
本篇文章阐述了netflix团队在对于媒体播放声音质量上进行的在技术上的相关处理，并且针对不同声音比特率下，网络吞吐量和视频比特率的变化关系；
netflix团队针对通过观察声音比特率的提高对网络和视频的影响得出适用流的想法来提高声音的质量。提高声音质量上不仅要考虑上述的问题还有诸如
设备硬件问题以及算法设计上需要考虑的问题。

Tip
这里给出Android Crash案列的分析，该案例中均是自己在项目中的所得
https://blog.csdn.net/qq_40073459/article/details/104023544

Share
Android学习笔记分享
https://blog.csdn.net/qq_40073459/article/details/104031595
